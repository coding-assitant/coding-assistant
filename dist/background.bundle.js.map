{"version":3,"file":"background.bundle.js","mappings":"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","sources":["webpack://chajian2.0/./node_modules/marked/lib/marked.esm.js","webpack://chajian2.0/./src/services/modelService.js","webpack://chajian2.0/./src/background/background.js"],"sourcesContent":["/**\n * marked v14.1.3 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape$1(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nconst noopTest = { exec: () => null };\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape$1(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape$1(text),\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (/^ {0,3}>/.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n                    .replace(/^ {0,3}>[ \\t]?/gm, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens[tokens.length - 1];\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && /^[ \\t]*$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<[a-z].*>`, 'i');\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(/\\t/g, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(/\\t/g, '    ').search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n[ \\t]*\\n[ \\t]*$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n            list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape$1(cap[1]),\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape$1(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape$1(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape$1(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape$1(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n}\n\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(/^\\S*/)?.[0];\n        const code = text.replace(/\\n$/, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape$1(langString)\n            + '\">'\n            + (escaped ? code : escape$1(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${text}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape$1(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\nexport { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n//# sourceMappingURL=marked.esm.js.map\n","import fetchSSE from '../utils/fetchSSE';\nimport {marked} from 'marked';\nimport {saveFavorite} from './favoriteService'\nimport {saveHistory} from './historyService';\n\nconst apiKey = process.env.API_KEY;\nlet controller;\n\n// 全局变量，用于管理正常回复和重新回复的气泡 ID\nconst globalState = {\n  currentModelBubbleId: null,\n  retryBubbleId: null,\n  latestMessageId: null,  // 用于追踪最新消息的 ID\n};\n\nlet globalText = '';  // 用于存储文本\n\n// 设置全局文本的函数\nexport const setGlobalText = (text) => {\n  globalText = text;\n  console.log('Global text set:', globalText);  // 打印设置的文本，确认是否成功\n};\n\n// 获取全局文本的函数\nexport const getGlobalText = () => globalText;\n\nconst messageHistory = new Map();\n\nlet uniqueIdCounter = 0;\n// 生成唯一的消息 ID\nfunction generateUserBubbleId() {\n  uniqueIdCounter += 1; // 每次生成 ID 时递增\n  return `${Date.now()}-${uniqueIdCounter}`; // 时间戳 + 计数器组合成唯一 ID\n}\n\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nfunction getStorageSync(key) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get([key], function(result) {\n      if (result[key]) {\n        resolve(result[key]);\n      } else {\n        reject(new Error(`Key ${key} not found`));\n      }\n    });\n  });\n}\n\nexport async function sendMessageToModel(messageContent, onUserMessage, onModelMessage, setIsSending, codetext='',isRetry = false, messageObject = null) {\n  isRetry = !!isRetry; // 确保 isRetry 为布尔值\n  controller = new AbortController();\n  const { signal } = controller;\n  const timestamp = new Date().toLocaleTimeString();\n  // 如果是新消息而不是重试，创建并存储消息对象\n  if (!isRetry) {\n    const userBubbleId = generateUserBubbleId();\n    messageObject = { id: userBubbleId, content: messageContent };\n    onUserMessage({ role: 'user', content: messageContent, timestamp, loading: false, id: userBubbleId });\n    saveHistory('user', messageContent);\n    messageHistory.set(userBubbleId, messageObject);  // 将完整的消息对象存入 Map\n    globalState.latestMessageId = userBubbleId; // 更新最新消息 ID\n    // console.log(\"新消息存储到 messageHistory:\", userBubbleId, messageContent);\n    globalState.retryBubbleId = null;\n    globalState.latestMessageId = userBubbleId; // 更新最新消息 ID\n  } else if (messageObject) {\n    // console.log(\"重试消息使用的 userBubbleId:\", messageObject.id);\n    if (!messageObject) {\n      return;\n    }\n  }\n\n  let modelBubbleId = null;\n  let loadingBubbleId = generateUserBubbleId();\n  let isFirstUpdate = true;\n\n  if (isRetry && messageObject) {\n    modelBubbleId = globalState.retryBubbleId;\n    onModelMessage({ role: 'model', content: '', loading: false, id: modelBubbleId });\n    onModelMessage({ role: 'system', content: '重新回复中...', timestamp: '', loading: true, id: modelBubbleId });\n  } else {\n    onModelMessage({ role: 'system', content: '模型正在思考中...', timestamp: '', loading: true, id: loadingBubbleId });\n  }\n\n  let modelResponseContent = \"\";\n\n  try {\n    setIsSending(true);\n\n\n    console.log('发送请求参数:', {\n      inputs: { code: codetext },\n      query: messageObject.content,\n      response_mode: 'streaming',\n      id: await getStorageSync('id')\n    });\n\n    await fetchSSE('http://172.16.215.118:8888/v1/chat-messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      //   'Authorization': `Bearer app-8fXyKoEq2Ka1XI3ZSs1FftaG`\n      },\n      body: JSON.stringify({\n        // inputs:\n        //     {\n        //       'code': codetext,\n        //     },\n        query: messageObject.content,\n        // response_mode: \"streaming\",\n        user_id: await getStorageSync('key'),\n        solution_id: 158709\n      }),\n      signal,\n      onMessage: (data) => {\n        console.log(\"data : \", data);\n        try {\n          //{\"event\": \"message\", \"conversation_id\": \"71468e0b-b489-4e25-965e-bd86467bff04\", \"message_id\": \"d8792cc9-5b8b-4532-80b5-dedfc1200f00\", \"created_at\": 1734343651, \"task_id\": \"9040f0d7-f504-4b44-858f-5c904b882c1e\", \"id\": \"d8792cc9-5b8b-4532-80b5-dedfc1200f00\", \"answer\": \"include\", \"from_variable_selector\": null}\n          const parsedData = JSON.parse(data);\n          console.log(parsedData)\n          const content = parsedData.answer || \"\";\n          modelResponseContent += content;\n\n          if (isRetry && isFirstUpdate) {\n            onModelMessage({ role: 'system', content: '', loading: false, id: modelBubbleId });\n            isFirstUpdate = false;\n          } else if (!modelBubbleId) {\n            onModelMessage({ role: 'system', content: '', loading: false, id: loadingBubbleId });\n            modelBubbleId = loadingBubbleId;\n          }\n\n          onModelMessage({\n            role: 'model',\n            content: marked.parse(modelResponseContent.trim()),\n            timestamp: timestamp,\n            loading: true,\n            id: modelBubbleId,\n          });\n          // }\n        } catch (err) {\n          console.error(\"解析数据时出错：\", err);\n        }\n      }\n    });\n\n    if (modelBubbleId) {\n      const finalContent = marked.parse(modelResponseContent.trim());\n      const contentWithButton = `${finalContent.trim()}${generateButtonHTML(modelBubbleId).trim()}`;\n      onModelMessage({\n        role: 'model',\n        content: contentWithButton,\n        timestamp: timestamp,\n        loading: false,\n        id: modelBubbleId,\n      });\n      saveHistory('model', modelResponseContent);\n      bindButtonEvents(modelBubbleId, modelResponseContent, onModelMessage, setIsSending, messageObject);\n\n      if (!isRetry) {\n        globalState.retryBubbleId = modelBubbleId;\n      }\n    }\n\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      onModelMessage({ role: 'system', content: '请求已中断', timestamp: '' });\n    } else {\n      onModelMessage({ role: 'error', content: '错误：无法连接到模型', timestamp });\n    }\n  } finally {\n    setIsSending(false);\n  }\n}\n\nexport function cancelMessage() {\n  if (controller) controller.abort();\n}\n\nfunction bindButtonEvents(id, content, onModelMessage, setIsSending, messageObject) {\n  // 延迟绑定事件，确保按钮容器和按钮都已生成\n  setTimeout(() => {\n    // 检查按钮容器是否存在\n    const container = document.querySelector(`#button-container-${id}`);\n\n    // 绑定通用按钮事件\n    const bindButton = (selector, callback, description) => {\n      const button = container.querySelector(selector);\n      if (button) {\n        button.addEventListener('click', callback);\n        console.log(`绑定${description}事件: ${selector}`);\n      } else {\n        console.warn(`${description}未找到: ${selector}`);\n      }\n    };\n\n    // 绑定复制按钮事件\n    bindButton('.copy-button', () => {\n      console.log('复制按钮被点击');\n      fallbackCopyTextToClipboard(content);\n    }, '复制按钮');\n\n    // 绑定重试按钮事件\n\n    bindButton('.retry-button', () => {\n      console.log('当前最新消息ID:', globalState.latestMessageId);\n      console.log('当前重试的消息ID:', messageObject?.id);\n\n      if (!messageObject) {\n        console.error('重试失败：messageObject 为空');\n        return;\n      }\n\n      if (messageObject.id !== globalState.latestMessageId) {\n        alert('暂不支持历史消息重新回复');\n        return;\n      }\n\n      const originalMessageData = messageHistory.get(messageObject.id);\n      if (!originalMessageData) {\n        console.error('重试失败：未找到原始用户输入');\n        return;\n      }\n\n      console.log('重试使用的消息数据:', originalMessageData);\n\n      // 修正参数传递\n      sendMessageToModel(\n          originalMessageData.content, // 用户消息内容\n          null, // 不触发用户消息渲染\n          onModelMessage, // 渲染模型响应的回调\n          setIsSending, // 控制发送状态的回调\n          '', // 代码内容\n          true, // 标记为重试\n          originalMessageData // 传递正确的消息对象\n      );\n    }, '重试按钮');\n\n\n    // 绑定收藏按钮事件\n    bindButton('.favorite-button', () => {\n      console.log('收藏按钮被点击');\n      saveFavorite(content);\n      alert('已收藏');\n    }, '收藏按钮');\n  }, 100); // 延迟 100ms 检查并绑定事件\n}\n\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n  textArea.style.position = 'fixed';\n  textArea.style.opacity = '0';\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand('copy');\n    alert('已复制到剪贴板');\n  } catch (err) {\n    console.error('复制到剪贴板失败:', err);\n    alert('复制失败，请手动复制');\n  }\n  document.body.removeChild(textArea);\n}\n\n// 生成按钮 HTML 的辅助函数\nfunction generateButtonHTML(id) {\n  return `\n    <div class=\"button-container\" id=\"button-container-${id}\">\n      <button class=\"copy-button\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g clip-path=\"url(#clip0_406_3945)\">\n            <path d=\"M16.8602 5H12.0002V0.016L16.8602 5ZM10.0002 7V0H5.00015C4.2045 0 3.44144 0.31607 2.87883 0.87868C2.31622 1.44129 2.00015 2.20435 2.00015 3V19H17.0002V7H10.0002ZM19.0002 7.01V21.038H7.00015V24H22.0002V10L19.0002 7.01Z\" fill=\"#374957\"/>\n          </g>\n          <defs>\n            <clipPath id=\"clip0_406_3945\">\n              <rect width=\"24\" height=\"24\" fill=\"white\"/>\n            </clipPath>\n          </defs>\n        </svg>\n      </button>\n      <button class=\"favorite-button\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g clip-path=\"url(#clip0_406_2240)\">\n            <path d=\"M14.7618 11.5869C14.2152 11.8981 13.6192 12.1132 12.9998 12.2229V23.8739C13.5269 23.7713 14.0336 23.5832 14.4998 23.3169L20.5268 19.8379C21.286 19.3978 21.9164 18.7662 22.355 18.0062C22.7937 17.2462 23.0254 16.3844 23.0268 15.5069V8.54693C23.0236 8.01274 22.9342 7.48257 22.7618 6.97693L14.7618 11.5869Z\" fill=\"#374957\"/>\n            <path d=\"M10.242 9.8569C10.7775 10.165 11.3846 10.3271 12.0024 10.3271C12.6203 10.3271 13.2274 10.165 13.7629 9.8569L21.763 5.2469C21.4086 4.83978 20.9905 4.49293 20.525 4.2199L14.5 0.736897C13.7394 0.299519 12.8773 0.0693359 12 0.0693359C11.1226 0.0693359 10.2605 0.299519 9.49995 0.736897L3.47295 4.2169C3.024 4.47979 2.61908 4.81149 2.27295 5.1999L10.242 9.8569Z\" fill=\"#374957\"/>\n            <path d=\"M11 12.2232C10.3802 12.1138 9.78389 11.8986 9.23699 11.5872L1.25699 6.92322C1.07232 7.4449 0.976324 7.99382 0.972992 8.54722V15.5072C0.974454 16.3847 1.20609 17.2465 1.64478 18.0065C2.08347 18.7665 2.71386 19.3981 3.47299 19.8382L9.49999 23.3172C9.96626 23.5835 10.473 23.7716 11 23.8742V12.2232Z\" fill=\"#374957\"/>\n          </g>\n          <defs>\n            <clipPath id=\"clip0_406_2240\">\n              <rect width=\"24\" height=\"24\" fill=\"white\"/>\n            </clipPath>\n          </defs>\n        </svg>\n      </button>\n      <button class=\"retry-button\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g clip-path=\"url(#clip0_405_1548)\">\n            <path d=\"M3.08615 10.6841C3.8103 5.76306 8.3866 2.36083 13.3076 3.08498C14.9866 3.33203 16.5615 4.04842 17.8511 5.15163L16.6902 6.31251C16.3011 6.7017 16.3012 7.33267 16.6905 7.72176C16.8773 7.90851 17.1306 8.01347 17.3948 8.01351H21.9647C22.515 8.01351 22.9611 7.56739 22.9611 7.01705V2.44715C22.961 1.89681 22.5148 1.45077 21.9644 1.45087C21.7003 1.45091 21.4469 1.55587 21.2601 1.74262L19.9646 3.03803C15.0245 -1.36557 7.44996 -0.930701 3.04635 4.00937C1.48628 5.75947 0.473881 7.92878 0.134578 10.2486C0.000799559 11.071 0.559034 11.8462 1.38141 11.98C1.4555 11.992 1.53033 11.9985 1.60539 11.9994C2.3578 11.9913 2.98937 11.4303 3.08615 10.6841Z\" fill=\"#374957\"/>\n            <path d=\"M22.3939 11.9992C21.6415 12.0073 21.0099 12.5684 20.9131 13.3146C20.189 18.2356 15.6127 21.6378 10.6917 20.9137C9.0127 20.6666 7.43773 19.9503 6.14815 18.8471L7.30904 17.6862C7.69814 17.297 7.69804 16.666 7.30881 16.2769C7.12201 16.0902 6.86866 15.9852 6.60451 15.9852H2.03471C1.48437 15.9852 1.03824 16.4313 1.03824 16.9816V21.5515C1.03838 22.1019 1.4846 22.5479 2.03494 22.5478C2.29909 22.5478 2.55244 22.4428 2.73924 22.2561L4.03465 20.9606C8.97356 25.3647 16.5476 24.9312 20.9517 19.9922C22.5126 18.2418 23.5255 16.0717 23.8647 13.7511C23.999 12.9287 23.4413 12.1532 22.619 12.0189C22.5446 12.0067 22.4693 12.0001 22.3939 11.9992Z\" fill=\"#374957\"/>\n          </g>\n          <defs>\n            <clipPath id=\"clip0_405_1548\">\n              <rect width=\"24\" height=\"24\" fill=\"white\"/>\n            </clipPath>\n          </defs>\n        </svg>\n      </button>      \n    </div>\n  `;\n}","// 在 background.js 中导入 setGlobalText\nimport { setGlobalText } from '../services/modelService';\nconsole.log(setGlobalText);  \n\nchrome.runtime.onInstalled.addListener(() => {\n  // 设置侧边栏行为为点击扩展图标时打开侧边栏\n  chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });\n});\n\n// 监听浏览器图标点击事件\nchrome.action.onClicked.addListener((tab) => {\n  // 发送消息到当前激活的标签页，通知 contentScript.js 切换侧边栏的显示状态\n  chrome.tabs.sendMessage(tab.id, { action: 'toggleSidebar' });\n  // 切换侧边栏显示状态\n  chrome.sidePanel.open({ windowId: tab.windowId }).catch((err) => {\n    console.error('Error opening side panel:', err);\n  });\n});\n\n// background.js\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message.action === 'openSidePanel') {\n    // 获取当前活动标签页的 windowId\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      const tab = tabs[0];\n      chrome.sidePanel.open({ windowId: tab.windowId })\n        .catch((err) => {\n          console.error('Error opening side panel:', err);\n        });\n    });\n  }\n});\n\n// 根据特定条件在特定网站启用侧边栏\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (tab.url && tab.url.startsWith(\"http://ojo.bnu.edu.cn\")) {\n    // 当页面加载完成时，启用侧边栏\n    chrome.sidePanel.setOptions({\n      tabId,\n      path: 'sidepanel.html',\n      enabled: true\n    });\n  } else {\n    // 对其他页面禁用侧边栏\n    chrome.sidePanel.setOptions({\n      tabId,\n      enabled: false\n    });\n  }\n});\n\n// 获取页面Cookies\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && tab.url) {\n    chrome.cookies.getAll({ url: tab.url }, (cookies) => {\n      console.log(tab.url)\n      let username = null;\n      for (const cookie of cookies) {  // Use for...of loop to iterate over the array\n        if (cookie.name === 'HUSTOJ_user') {  // Correct way to access the 'name' property\n          username = cookie.value;  // Correct way to access the 'value' property\n        }\n      }\n\n      // If a username was found, store it\n      if (username) {\n        chrome.storage.local.set({ key: username }, function() {\n          console.log('Data saved to local storage: ' + username);\n        });\n      } else {\n        console.log('Username cookie not found.');\n      }\n\n      const regex = /https?:\\/\\/[a-zA-Z0-9.-]+\\/showsource\\.php\\?id=\\d+/;\n      if (regex.test(tab.url)) {\n        const urlObj = new URL(tab.url);\n        const id = urlObj.searchParams.get(\"id\");\n\n        if (id) {\n          console.log(\"ID:\", id);\n          chrome.storage.local.set({ id: id }, function() {\n            console.log('Data saved to local storage: ' + id);\n          });\n        }\n      }\n    });\n  }\n});\n\n\n\n"],"names":["_defaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","changeDefaults","newDefaults","escapeTest","escapeReplace","RegExp","source","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape$1","html","encode","test","replace","caret","edit","regex","opt","obj","name","val","valSource","getRegex","cleanUrl","href","encodeURI","noopTest","exec","splitCells","tableRow","count","cells","match","offset","str","escaped","curr","split","i","trim","shift","length","pop","splice","push","rtrim","c","invert","l","suffLen","currChar","charAt","slice","outputLink","cap","link","raw","lexer","title","text","state","inLink","token","type","tokens","inlineTokens","_Tokenizer","options","rules","constructor","this","space","src","block","newline","code","codeBlockStyle","fences","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","indentCodeCompensation","lang","inline","anyPunctuation","heading","trimmed","depth","hr","blockquote","lines","inBlockquote","currentLines","currentRaw","currentText","top","blockTokens","lastToken","oldToken","newText","newToken","substring","list","bull","isordered","ordered","start","loose","items","itemRegex","endsWithBlankLine","endEarly","itemContents","line","t","repeat","nextLine","blankLine","indent","trimStart","search","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","rawLine","nextLineWithoutTabs","ischecked","istask","task","checked","trimEnd","spacers","filter","hasMultipleLineBreaks","some","pre","def","tag","toLowerCase","table","headers","aligns","rows","item","header","align","row","cell","lheading","paragraph","escape","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","b","indexOf","level","findClosingBracket","linkLen","reflink","links","nolink","emStrong","maskedSrc","prevChar","emStrongLDelim","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","emStrongRDelimAst","emStrongRDelimUnd","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_backpedal","inlineText","bullet","_paragraph","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","_punctuation","_inlineComment","_inlineLabel","inlineNormal","blockSkip","reflinkSearch","inlinePedantic","inlineGfm","inlineBreaks","normal","_Lexer","inlineQueue","Object","create","lex","lexInline","next","lastParagraphClipped","cutSrc","extTokenizer","call","startBlock","startIndex","Infinity","tempSrc","tempStart","forEach","getStartIndex","errMsg","charCodeAt","console","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","_Renderer","parser","langString","parse","parseInline","body","j","listitem","itemBody","checkbox","unshift","tablecell","tablerow","k","content","strong","em","cleanHref","out","image","_TextRenderer","_Parser","textRenderer","anyToken","renderers","genericToken","ret","textToken","_Hooks","static","Set","preprocess","markdown","postprocess","processAllTokens","provideLexer","provideParser","markedInstance","defaults","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","args","use","callback","values","concat","tableToken","listToken","childTokens","flat","pack","opts","ext","prevRenderer","apply","extLevel","prop","rendererProp","rendererFunc","tokenizerProp","tokenizerFunc","prevTokenizer","hooksProp","hooksFunc","prevHook","passThroughHooks","has","arg","Promise","resolve","then","packWalktokens","blockType","origOpt","throwError","onError","prototype","toString","all","catch","e","message","msg","reject","getDefaults","globalText","Map","log","chrome","runtime","onInstalled","addListener","sidePanel","setPanelBehavior","openPanelOnActionClick","action","onClicked","tab","tabs","sendMessage","id","open","windowId","err","onMessage","sender","sendResponse","query","active","currentWindow","onUpdated","tabId","changeInfo","startsWith","path","enabled","status","cookies","getAll","_step","username","_iterator","_createForOfIteratorHelper","s","n","done","cookie","value","f","storage","local","set","key","URL","searchParams","get"],"sourceRoot":""}